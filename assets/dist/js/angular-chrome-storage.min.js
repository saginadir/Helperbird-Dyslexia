"use strict";angular.module("chromeStorage",[]).factory("chromeStorage",function(e){var r=null;try{r=chrome.storage.local}catch(o){console.log("could not initiate chrome local storage: "+o)}/**
         * These are provided and updated only for debugging purposes.
         */
var n=null,t={},c=function(o){var n=e.defer();return r.getBytesInUse(o,function(e){chrome.runtime.lasterror?(console.log("error retrieving bytes in use for keys "+o),n.reject(chrome.runtime.lasterror.message)):(console.log("retrieved bytes in use for keys "+o+": "+e),n.resolve(e))}),n.promise};return{getDebuggingTotalBytesInUse:function(){return n},getDebuggingCache:function(){return t},/**
             * Returns the usage of the current storage quota, as a number between 0.0 and 1.0
             */
getDebuggingPercentUsed:function(){var e=n/r.QUOTA_BYTES;return e},getDebuggingSizeOf:function(e){return angular.toJson(t[e]).length},updateDebuggingCache:function(){var o=e.defer();r.get(null,function(e){chrome.runtime.lasterror?o.reject(chrome.runtime.lasterror.message):
//console.log('get then for all keys : ' + angular.toJson(value));
o.resolve(e)}),o.promise.then(function(e){t=e})},updateDebuggingTotalBytes:function(){c(null).then(function(e){console.log("total bytes in use: "+e),n=e})},clearCache:function(){
// console.log('clearing local cache');
r.clear(function(){chrome.runtime.lastError?console.error("error clearing local cache"+chrome.runtime.lastError):console.log("cache has been cleared")})},drop:function(e){r.remove(e,function(){chrome.runtime.lasterror&&console.error(chrome.runtime.lasterror.message)})},get:function(o){var n=e.defer();return r.get(o,function(e){
// console.log('getTotalBytesInUse then with key ' + key + " : " + angular.toJson(value));
var r=e[o];n.resolve(r)}),n.promise},/**
             * gets the value of key from the cache, or calls the fallback function, and populates the cache
             * with the value of the promise returned
             */
getOrElse:function(o,n){
// console.log('getOrElse called with  cached key ' + key);
var t=e.defer();return r.get(o,function(e){
// console.log('getOrElse then with cached key ' + key + " : " + angular.toJson(value));
var c=e[o];void 0==c||null==c?
// console.log("no cached value for "+ key + ". using fallback method.");
n().then(function(e){c=e;
// console.log("caching value for "+ key + " : " + angular.toJson(keyValue));
var n={};n[o]=c,r.set(n,function(){chrome.runtime.lasterror&&console.error(chrome.runtime.lasterror.message)}),t.resolve(c)}):t.resolve(c)}),t.promise},/**
             *
             */
set:function(e,o){var n={};n[e]=o,r.set(n,function(){chrome.runtime.lasterror&&console.error(chrome.runtime.lasterror.message)})},/**
             * gets the value of key from the cache, or calls the fallback function, and populates the cache
             * with the value of the promise returned
             */
forceGet:function(o,n){
// console.log('getOrElse called with  cached key ' + key);
var t=e.defer();return n().then(function(e){keyValue=e;
// console.log("caching value for "+ key + " : " + angular.toJson(keyValue));
var n={};n[o]=keyValue,r.set(n,function(){chrome.runtime.lasterror&&console.error(chrome.runtime.lasterror.message)}),t.resolve(keyValue)}),t.promise},/**
             * Returns the quota of the current storage method, in bytes
             */
getQuota:function(){return r.QUOTA_BYTES}}});